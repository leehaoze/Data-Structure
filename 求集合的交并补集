#include <iostream>
#include <deque>
#include <string>
#include <vector>
#include <queue>
#include <cstdio>
#include <stack>
#include <algorithm>
#include <cstring>
#include <cctype>
#include <cstdio>
#include <cmath>
#include <cstdlib>

using namespace std;

#define MAXN 2147483649

typedef struct LNode {
    int data;
    struct LNode *next;
} LNode, *LinkList;

bool GetElem_L(LinkList L, int i, int &e) {
    int count = 1;
    LinkList p = L->next;
    while (p != NULL && count < i) {
        p = p->next;
        ++count;
    }
    if (p == NULL || count > i)
        return false;
    e = p->data;
    return true;
}

bool ListInsert_L(LinkList L, int i, int &e) {
    int count = 1;
    LinkList p = L->next;
    while (p != NULL && count < i - 1) {
        p = p->next;
        ++count;
    }

    if (p == NULL || count > i - 1)
        return false;

    LinkList s = (LinkList) malloc(sizeof(LNode));
    if (s == NULL)
        return false;
    s->data = e;
    s->next = p->next;
    p->next = s;

    return true;

}

bool LinkDelete_L(LinkList &L, int i, int &e) {
    int count = 1;
    LinkList p = L->next;
    while (p != NULL && count < i - 1) {
        p = p->next;
        count++;
    }
    if (p == NULL || count > i - 1)
        return false;

    e = p->next->data;
    LinkList s = p->next;
    p->next = s->next;
    free(s);
    return true;
}

bool CreateList_L(LinkList &L, int n) {//顺序输入n个元素并储存
    L = (LinkList) malloc(sizeof(LNode));
    if (L == NULL) return false;
    L->next = NULL;
    LinkList s = L;
    for (int i = 0; i < n; ++i) {
        LinkList p = (LinkList) malloc(sizeof(LNode));
        if (p == NULL) return false;
        p->next = NULL;
        scanf("%d", &p->data);
        s->next = p;
        s = s->next;
    }
    return true;
}

bool FreeList_L(LinkList &L) {
    while (L) {
        LinkList p = L;
        L = L->next;
        free(p);
    }
    return true;
}

bool set_union(LinkList &La, LinkList &Lb, LinkList &Lc) {//线性表合并为新的表，并且不对旧表差生影响
    LinkList pa, pb, pc;
    pa = La->next;
    pb = Lb->next;
    pc = Lc;
    while (pa && pb) {
        LinkList temp = new LNode;
        if (pa->data == pb->data) {
            temp->data = pa->data;
            pa = pa->next;
            pb = pb->next;
        } else if (pa->data < pb->data) {
            temp->data = pa->data;
            pa = pa->next;
        } else {
            temp->data = pb->data;
            pb = pb->next;
        }
        pc->next = temp;
        pc = pc->next;
    }
    while (pa) {
        LinkList temp = new LNode;
        temp->next = NULL;
        temp->data = pa->data;
        pa = pa->next;
        pc->next = temp;
        pc = pc->next;
    }
    while (pb) {
        LinkList temp = new LNode;
        temp->next = NULL;
        temp->data = pb->data;
        pb = pb->next;
        pc->next = temp;
        pc = pc->next;
    }
}

bool set_difference(LinkList &La, LinkList &Lb, LinkList &Lc, int lena, int lenb) {
    LinkList pa, pb, pc;
    pa = La->next;
    pb = Lb->next;
    pc = Lc;
    int *hash = new int[MAXN];
    memset(hash, 0, sizeof(hash));
    if (lena > lenb) {
        for (int i = 0; i < lena && pa; ++i) {
            hash[pa->data] = 1;
            pa = pa->next;
        }
        for (int i = 0; i < lenb && pb; ++i) {
            if (hash[pb->data] == 1) {
                LinkList temp = new LNode;
                temp->data = pb->data;
                temp->next = NULL;
                pc->next = temp;
                pc = pc->next;
            }
            pb = pb->next;
        }
    } else {
        for (int i = 0; i < lenb && pb; ++i) {
            hash[pb->data] = 1;
            pb = pb->next;
        }
        for (int i = 0; i < lena && pa; ++i) {
            if (hash[pa->data] == 1) {
                LinkList temp = new LNode;
                temp->data = pa->data;
                temp->next = NULL;
                pc->next = temp;
                pc = pc->next;
            }
            pa = pa->next;
        }
    }
    return true;
}

bool set_minus(LinkList &La, LinkList &Lb, LinkList &Lc,int lena,int lenb){
    int *hash = new int[MAXN];
    memset(hash,0,sizeof(hash));
    LinkList pa = La->next;
    LinkList pb = Lb->next;
    LinkList pc = Lc;
    while(pb){
        hash[pb->data] = 1;
        pb = pb->next;
    }
    while(pa){
        if(hash[pa->data] == 0){
            LinkList temp = new LNode;
            temp->data = pa->data;
            temp->next = NULL;
            pc->next = temp;
            pc = pc->next;
        }
        pa = pa->next;
    }
    return true;
}

void show_List(LinkList &L) {
    LinkList p = L->next;
    bool first = true;
    while (p) {
        if (!first) cout << ' ';
        cout << p->data;
        p = p->next;
        if (first)
            first = false;
    }
    cout << endl;
}

int main() {
#ifdef LOCAL
    freopen("IN.txt", "r", stdin);
#endif
    int T;
    int cases = 1;
    scanf("%d", &T);
    while (T--) {
        int numa, numb;
        LinkList Set_A = (LinkList) malloc(sizeof(LNode));
        LinkList Set_B = (LinkList) malloc(sizeof(LNode));
        scanf("%d", &numa);
        CreateList_L(Set_A, numa);
        scanf("%d", &numb);
        CreateList_L(Set_B, numb);
        LinkList Set_C = (LinkList) malloc(sizeof(LNode));
        Set_C->next = NULL;
        printf("Case #%d:\n",cases++);
        set_difference(Set_A,Set_B,Set_C,numa,numb);
        show_List(Set_C);
        FreeList_L(Set_C);
        Set_C = (LinkList) malloc(sizeof(LNode));
        Set_C->next = NULL;
        set_union(Set_A,Set_B,Set_C);
        show_List(Set_C);
        FreeList_L(Set_C);
        Set_C = (LinkList) malloc(sizeof(LNode));
        Set_C->next = NULL;
        set_minus(Set_A,Set_B,Set_C,numa,numb);
        show_List(Set_C);
        FreeList_L(Set_C);
        Set_C = (LinkList) malloc(sizeof(LNode));
        Set_C->next = NULL;
        set_minus(Set_B,Set_A,Set_C,numb,numa);
        show_List(Set_C);
        FreeList_L(Set_C);
        FreeList_L(Set_A);
        FreeList_L(Set_B);
    }
    return 0;
}
